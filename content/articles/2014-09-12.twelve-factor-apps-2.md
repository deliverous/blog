Title: The Twelve Factor Apps 2/2
Tags: 12factor, heroku
Author: Thomas
Summary: Etude de *The Twelve Factor Apps*. La théorisation d'une bonne application par Adam Wiggins l'un des fondateurs de [Heroku](https://www.heroku.com/) seconde partie
Icon: /images/thumbnails/2014-05-26.twelve-factor-apps-1.illustration__square.jpg
Status: draft

*The Twelve Factor Apps* c'est la définition des bonnes pratiques que doivent suivre un développeur pour produire une application portable et capable de passer à l'échelle. Ces 12 règles ont été rédigées par Adam Wiggins l'un des fondateurs de [Heroku](https://www.heroku.com/). 

Cet article est la suite de notre traduction libre entammé dans [The Twelve Factor Apps 1/2](2014-05-26.twelve-factor-apps-1.html)

![Box origami]({filename}/images/2014-05-26.twelve-factor-apps-1.illustration.jpg)

# 7 - Exposition de port

La seule façon de contacter un service, c'est par le réseau. Pour exposer un service il suffit donc de déclarer le port réseau utilisé.

Par exemple, une application web en PHP pourra etre exécuté dans un Apache avec le module PHP et exposé sur le port 80. Une application Java pourra être lancé dans un Tomcat et exposé sur le port 8080.

Une application 12 factor apps est auto-suffisante elle ne doit pas dépendre d'éléments à l'exécution pour bien fonctionner. Elle écoute et parle sur un port réseau. 

En développement il sera par exemple possible d'utiliser le service avec l'url [http://localhost:8000](http://localhost:8000). En production un loadbalancer pourra servir de point d'entrée vers de nombreuses instances de l'application.

C'est typiquement mis en place par l'introduction d'une librairie de service web dans l'application. Par exemple [Tornado](http://www.tornadoweb.org/) pour Python, [Unicorn](http://unicorn.bogomips.org/) pour Ruby ou [Jetty](http://www.eclipse.org/jetty/) pour Java.

Le protocole HTTP n'est qu'un exemple des services réseau disponible. MySQL, Redis ou ejabberd utilisent des protocoles différents sur d'autres ports réseaux.

Notez qu'en exposant un service sur le réseau, il est alors utilisable comme une resource distante comme évoqué dans le point 4 en décrivant le service par son URL dans la configuration (cf point 3).

# 8 - Concurrence

La montée se charge se fait en augmentant le nombre d'instances des composants applicatifs.

C'est une base d'Unix, pour augmenter la capacité de traitement d'une application, il suffit bien souvent d'augmenter le nombre de processus. C'est par exemple vraie avec Apache httpd mais aussi avec Postifx ou Spamassassin. À l'inverse de Java qui réserve un ensemble de ressources au près du système et se débrouille avec.
Une application 12 factor doit suivre ce même principe pour augmenter la capacité, il faut pouvoir augmenter le nombre de nombre de processus. 

L'architecture de l'application doit permettre ce mode de fonctionnement. Par exemple pour prendre en charge les requêtes HTTP on pourra instanciés des processus web, pour prendre en compte les traitements longs on pourra instanciés des composants "worker" si la charge lié à l'une ou l'autre des types de requête augmente il suffit d'augmenter le nombre de worker ou de processus web.

Cela n'influe en rien sur le fonctionnement interne d'un composant applicatif. Que l'architecture soit basé sur une consommation d'événements asynchrone comme avec node.js ou EventMachine ou sur des files de messages avec des processus ou des threads Unix pour les consommer.


# 9. Jetable

Maximiser la robustesse grace à des démarrages rapides et des arrêts progressifs

Les processus dans 12 factor apps sont jetables, cela signifie qu'ils peuvent être démarrés ou arrêtés à la demande. Cela facilite le passage à l'échelle, le redéploiement rapide sur un changement de code ou de configuration, et la robustesse des déploiements en production.

Les processus devraient s'efforcer de minimiser le temps de démarrage. Idéalement , un processus prend quelques secondes à partir du moment de la commande de lancement est exécuté jusqu'à ce que le processus soit en place et prêt à recevoir des demandes ou des emplois. 

Les processus devrait se terminer gracieusement quand ils reçoivent un signal SIGTERM à partir du gestionnaire de processus. Pour un processus Web, l'arrêt progressif est réalisé en cessant d'écouter sur le port de service (refusant ainsi de nouvelles demandes), permettant la fin des requêtes en cours avant de quitter. Dans ce modèle, il est implicite que les requêtes HTTP sont courtes (pas plus de quelques secondes), ou dans le cas de longues requete, le client doit parfaitement tenter de se reconnecter lorsque la connexion est perdue.

Pour un processus worker, l'arrêt progressif est réalisé en retournant le travail en cours de la file d'attente de travail. Par exemple, sur [RabbitMQ](www.rabbitmq.com) le worker peut envoyer un NACK ; sur [Beanstalkd](https://github.com/kr/beanstalkd), le travail est retourné à la file d'attente automatiquement chaque fois qu'un worker se déconnecte. Dans ce modèle, il est implicite que les jobs soient réentrant.

Les processus devraient également être robuste contre la mort subite, dans le cas d'une défaillance du matériel sous-jacent. Bien que ce soit un phénomène beaucoup moins fréquent que l'arrêt progressif avec SIGTERM, il peut se produire. Une approche recommandée est l'utilisation d'un backend de file d'attente robuste, comme [Beanstalkd](https://github.com/kr/beanstalkd), qui renvoie les jobs à la file d'attente lorsque les clients se déconnectent ou time out. De toute façon, une application 12 facteur est architecturée pour gérer inattendus.

# 10. Parité Dev/prod

Garder le developpement, le staging et la production aussi similaire que possible.


# 11. Logs

Traiter les logs comme des flux d'evenements.


# 12. Processus d'Admin

Exécuter les tâches d'admin et de gestion comme des processus ponctuels.


---
Photo par [Simona](https://www.flickr.com/photos/mammaoca2008/4344228722)

